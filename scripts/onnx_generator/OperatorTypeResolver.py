import inspect
import os
import pathlib

class OperatorTypeSwitch:
    _template_resolveType = '''
uint32_t {constraint} = 0;
if (ctx->{inOrOutput}->{name}) {{
    {constraint} = ctx->{inOrOutput}->{name}->tensor->data_type;
}}
'''
    _template_switch = '''
switch ( {constraint} ) {{
    case 0: //constrained tensor is not set (maybe optional?), just take next case
    {cases}
    default: {{
        fprintf(stderr, "no matching type for constraint '{constraint}' found!\\n");
        break;
    }}
}}
'''
    _template_case = '''
case {case}: {{ {content} break; }}
'''

    _template = '''
{{
    {resolveTypes}
    {switch}
}}
'''
    def __init__(self, schema):
        self.schema = schema

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"OperatorTypeSwitch({self.schema.__repr__()})"

    def text(self, indent=4):
        resolveTypes = []
        cases = []

        for constraint in self.schema.constraints.keys():
            inOrOutput = None
            name = None
            optional = False
            for input in self.schema.inputs:
                if constraint != input.constraint:
                    continue
                inOrOutput = "input"
                name = input.name
                if input.optional:
                    continue
                break
            else:
                for output in self.schema.outputs:
                    if constraint != output.constraint:
                        continue
                    inOrOutput = "output"
                    name = output.name
                    if output.optional:
                        continue
                    break
            resolveTypes.append(self._template_resolveType.format(
                constraint = constraint,
                inOrOutput = inOrOutput,
                name = name,
            ).strip())


        permutationsMap = self.schema.constraints.typePermutationsMap()
        if not permutationsMap:
            return "/* skipping constraint test, because no constraint exist */"
        return self._template.format(
            resolveTypes = "\n".join(resolveTypes).strip().replace("\n",f"\n{' '*indent}"),
            switch = self._text_walkPermutationsMap(permutationsMap, indent).replace('\n','\n'+' '*indent)
        ).strip()

    def _text_walkPermutationsMap(self, node, indent=4):
        cases = []
        for k,v in node.items():
            case = k[-1][1].onnxTensorDataTypes()
            if not case:
                cases.append(f"/* skip non tensor constraint '{k[-1][0]}' ('{k[-1][1].original}') */")
                continue
            operator_name = self.schema.operator_name
            typePermutationText = self.schema.constraints.typePermutationText(k)
            if not v:
                cases.append(self._template_case.format(
                    case = case[0],
                    content = f"executer = (operator_executer) &{operator_name}__{typePermutationText};"
                ).strip())
            else:
                cases.append(self._template_case.format(
                    case = case[0],
                    content = self._text_walkPermutationsMap(v,indent)
                ).strip())
        return self._template_switch.format(
            constraint = list(node.keys())[0][-1][0],
            cases = "\n".join(cases).replace('\n','\n'+' '*indent)
        ).strip()

class OperatorTypeResolver:
    _template = '''
//this file was generated by {script}
#include "operators/{domain}/{operator_name}.h"
#include "operators/operator_stub.h"
#include <inttypes.h>
#include <stdio.h>

operator_executer resolve_{operator_name}(
    operator_context__{operator_name} *ctx
){{
    operator_executer executer = NULL;
    {switch}
    if (!executer) {{
        executer = &operator_stub;
    }}
    return executer;
}}
'''

    def __init__(self, schema, path):
        self.schema = schema
        self.path = path
        self.switch = OperatorTypeSwitch(self.schema).text()

    def text(self):
      return self._template.format(
        script=self._rel_path(inspect.getfile(inspect.currentframe())),
        operator_name=self.schema.operator_name,
        switch=self.switch,
        domain=self.schema.domain,
      )

    def filename(self):
        path = str(self.path)
        path += f"/{self.schema.domain}"
        path += f"/resolve_{self.schema.operator_name}.c"
        return pathlib.Path(path)

    def _rel_path(self, path):
        return os.path.relpath(os.path.realpath(path),os.path.realpath(self.path))

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"OperatorTypeResolver({self.schema.__repr__()}, {self.path.__repr__()})"
