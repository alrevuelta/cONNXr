import os
import inspect
import pathlib

class OperatorHeaderPrototype:
    _template = '''
{attribute}
{return_type} {name}(
  size_t                  n_input,
  Onnx__TensorProto    ** input,
  size_t                  n_attribute,
  Onnx__AttributeProto ** attribute,
  size_t                  n_output,
  Onnx__TensorProto    ** output
);
'''
    def __init__(self, name, return_type="operator_status", attribute=""):
        self.name = name
        self.attribute = attribute
        self.return_type = return_type

    def text(self):
        return self._template.format(
            name=self.name,
            attribute=self.attribute,
            return_type = self.return_type
        ).strip()

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"{self.__class__}({self.schema.__repr__()})"

class OperatorHeaderPrototypeAliases:
    def __init__(self, schema):
        self.schema = schema

    def text(self):
        return "\n".join([OperatorHeaderPrototypeAlias(
                            self.schema.operator_name,
                            t
                          ).text()
                          for t in self.schema.constraints.typePermutations() ])

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"{self.__class__}({self.schema.__repr__()})"

class OperatorHeaderPrototypeAlias(OperatorHeaderPrototype):
    def __init__(self, name, type):
        super().__init__(f"{name}__{type}", attribute='extern __attribute__((weak))')

class OperatorHeaderPrototypeResolver(OperatorHeaderPrototype):
    def __init__(self, name):
        super().__init__(f"resolve_{name}", return_type='operator_executer')

class OperatorHeaderDoxygen:
    _template = '''
/**
 * {domain} operator '{name}' version {version}
 *
 * @param[in]  n_input     Number of inputs ({range_input})
 * @param[in]  input       Array of pointers to the inputs
 * @param[in]  n_attribute Number of attributes
 * @param[in]  attribute   Array of pointers to the attributes
 * @param[in]  n_output    Numper of outputs ({range_output})
 * @param[out] output      Array of pointer to the outputs
 * @return                 Error code
 *
 * @retval     0        No Error
 * @retval     ENOSYS   Operator is stubbed
 * @retval     EINVAL   Invalid argument
 * @retval     ENOMEM   Out of Memory
 * @retval     EFAULT   Invalid addr
 * @retval     EDOM     Math argument out of domain
 * @retval     ERANGE   Math result not representable
 *
{doc}
{deprecated}
{constraints}
{inputs}
{outputs}
{attributes}
 *
 * @since version {version}
 *
{defs_filepath}
{doc_ref}
 */
'''
    def __init__(self, schema, path):
        self.schema = schema
        self.path   = path

    def text(self):
        return self._template.format(
            attributes=self.schema.attributes.text(" * "),
            deprecated=" * @deprecated Avoid usage!" if self.schema.deprecated else " * ",
            doc=self.schema.doc.text(" * "),
            doc_ref=f" * @see {self.schema.ref_doc}",
            domain=self.schema.domain,
            constraints=self.schema.constraints.text(" * "),
            range_input=self._range(*self.schema.range_input),
            inputs=self.schema.inputs.text(" * "),
            name=self.schema.name,
            range_output=self._range(*self.schema.range_output),
            outputs=self.schema.outputs.text(" * "),
            version=self.schema.version,
            defs_filepath=f" * @see {self._rel_path(self.schema.ref_file[0])}:{self.schema.ref_file[1]}",
        ).strip()

    def _range(self, min, max):
        if (min == max):
            return f"exactly {min}"
        else:
            return f"{min} to {max}"

    def _rel_path(self, path):
        return os.path.relpath(os.path.realpath(path),os.path.realpath(self.path))

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"{self.__class__}({self.schema.__repr__()})"

class OperatorHeader:
    _template_header = '''
//this file was generated by {script}
# ifndef OPERATOR_{header_name}_H
# define OPERATOR_{header_name}_H

# include "operators/operator.h"
# include "operators/operator_stub.h"

{doxygen}
{prototype}

{resolver}

{aliases}
# endif
'''

    def __init__(self, schema, path):
      self.schema = schema
      self.path = path

    def text(self):
        return self._template_header.format(
            script=self._rel_path(inspect.getfile(inspect.currentframe())),
            header_name=self.schema.operator_name.upper(),
            operator_name=self.schema.operator_name,
            doxygen = OperatorHeaderDoxygen(self.schema, self.path),
            prototype = OperatorHeaderPrototype(self.schema.operator_name),
            resolver = OperatorHeaderPrototypeResolver(self.schema.operator_name),
            aliases = OperatorHeaderPrototypeAliases(self.schema)
        )

    def filename(self, path=None):
        path = str(self.path) if path == None else str(path)
        path += f"/{self.schema.domain}"
        path += f"/{self.schema.operator_name}.h"
        return pathlib.Path(path)

    def _rel_path(self, path):
        return os.path.relpath(os.path.realpath(path),os.path.realpath(self.path))

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"{self.__class__}({self.schema.__repr__()})"