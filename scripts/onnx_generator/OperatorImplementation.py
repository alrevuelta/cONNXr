import inspect
import os

class OperatorCheckSameType:
    _template_check = '''
{{ // check constraint '{constraint}'
  size_t n_tensors = 0;
  Onnx__TensorProto *tensors[{n_tensors_max}];
  {find_inputs}
  {find_outputs}
  if ( !operator_tensorsAreOfSameType( tensors, n_tensors ) ) {{
    fprintf(stderr, "tensor type mismatch between: ")
    for (size_t i = 0; i < n_tensors; i++) {{
      fprintf(stderr, "%s, ", tensors[i]->name);
    }}
    fprintf(stderr, "\\n");
    exit(1);
  }}
}}
'''
_template_find = '''
{{ // find {inOrOutput}s for constraint '{constraint}' 
  char *names = {{ {names} }};
  n_tensors += operator_findTensors(
    tensors,
    names,
    sizeof(names)/sizeof(*names),
    {inOrOutput_list},
    {inOrOutput_length}
  );
}}
'''

    def __init__(self, schema):
        self.schema = schema

    def text(self,prefix=""):
        checks = []
        constraint2both = {}
        constraint2input = {}
        constraint2output = {}
        for input in self.schema.inputs:
            constraint2both.setdefault(input.constraint, []).append(input)
            constraint2input.setdefault(input.constraint, []).append(input)
            constraint2output.setdefault(input.constraint, [])
        for output in self.schema.outputs:
            constraint2both.setdefault(output.constraint, []).append(output)
            constraint2input.setdefault(output.constraint, [])
            constraint2output.setdefault(output.constraint, []).append(output)
        for constraint, inOrOutputs in constraint2both.items():
            if len(inOrOutputs) < 2:
                checks.append(f"// check of constraint '{constraint}' skipped")
            else:
                find_inputs = f"// no input for constraint '{constraint}'"
                find_outputs = f"// no output for constraint '{constraint}'"
                inputs = constraint2input[constraint]
                outputs = constraint2output[constraint]
                if inputs:
                    find_inputs = self._template_find.format(
                        constraint=constraint,
                        inOrOutput="input",
                        names=" ".join([f'"{i.name}"' for i in inputs]),
                        inOrOutput_list="input",
                        inOrOutput_length=len(inputs)
                    ).strip()
                if outputs:
                    find_outputs = self._template_find.format(
                        constraint=constraint,
                        inOrOutput="output",
                        names=", ".join([f'"{o.name}"' for o in outputs]),
                        inOrOutput_list="output",
                        inOrOutput_length=len(outputs)
                    ).strip()
                checks.append(self._template_check.format(
                    constraint=constraint,
                    n_tensors_max=len(inOrOutputs),
                    find_inputs=find_inputs,
                    find_outputs=find_outputs
                ).strip())
        return prefix + f"\n{prefix}".join(checks).strip()

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"OperatorCheckSameType({self.schema.__repr__()})"


class OperatorImplementation:
    _template = '''
//this file was generated by {script}
#include "{header_name}.h"

int {operator_name}(
  size_t                  n_input,
  Onnx__TensorProto    ** input,
  size_t                  n_attribute,
  Onnx__AttributeProto ** attribute,
  size_t                  n_output,
  Onnx__TensorProto    ** output
){{

  {checks_sameType}

  {checks_ofType}

  {switch}

}}
'''

    def __init__(self, schema, path):
        self.schema = schema
        self.path = path

    def text(self):
      return self._template.format(
        script=self._rel_path(inspect.getfile(inspect.currentframe())),
        header_name=self.schema.operator_name.upper(),
        operator_name=self.schema.operator_name,
        checks_sameType=OperatorCheckSameType(self.schema),
        checks_ofType="FIXME",
        switch="FIXME"
      )

    def _rel_path(self, path):
        return os.path.relpath(os.path.realpath(path),os.path.realpath(self.path))

    def __str__(self):
        return self.text()

    def __repr__(self):
        return f"OperatorImplementation({self.schema.__repr__()}, {self.path.__repr__()})"
