import argparse
import inspect
import itertools
import os
import sys

parser = argparse.ArgumentParser()
parser.add_argument(
  "onnx_cpp2py_export",
  help="path to directory of onnx_cpp2py_export.so"
)
parser.add_argument(
  "include",
  help="path to directory where to save headers"
)
parser.add_argument(
  "stubs",
  help="path to directory where to save stubs"
)
args = parser.parse_args()

path_onnx_cpp2py_export = os.path.realpath(os.path.abspath(args.onnx_cpp2py_export))
path_include = os.path.realpath(os.path.abspath(args.include))
path_stubs = os.path.realpath(os.path.abspath(args.stubs))

print(f"path onnx_cpp2py_export: {path_onnx_cpp2py_export}")
print(f"path include: {path_include}")
print(f"path stubs: {path_stubs}")

sys.path.insert(0, path_onnx_cpp2py_export)
import onnx_cpp2py_export

schemas = onnx_cpp2py_export.defs.get_all_schemas()

template_header = '''
//this file was generated by {script}
#ifndef OPERATOR_{NAME}_H
#define OPERATOR_{NAME}_H

#include "operator.h"
#include "onnx.pb-c.h"

{deprecated_define}
/**
 * op_status operator_{name}(
 *   size_t                  n_input,
 *   Onnx__TensorProto    ** input,
 *   size_t                  n_attribute,
 *   Onnx__AttributeProto ** attribute,
 *   size_t                  n_output,
 *   Onnx__TensorProto    ** output
 * )
{brief}
 *
 * @param[in]  n_input     Number of inputs ({input_constraint})
 * @param[in]  input       Array of pointers to the inputs
 * @param[in]  n_attribute Number of attributes
 * @param[in]  attribute   Array of pointers to the attributes
 * @param[in]  n_output    Numper of outputs ({output_constraint})
 * @param[out] output      Array of pointer to the outputs
 * @return                 status code
 *
{deprecated}
{constraints}
{attributes}
 *
 * @since version {since}
 * @see {file}:{line}
{documentation}
 */
op_status operator_{name}(
  size_t                  n_input,
  Onnx__TensorProto    ** input,
  size_t                  n_attribute,
  Onnx__AttributeProto ** attribute,
  size_t                  n_output,
  Onnx__TensorProto    ** output
);

#endif
'''

template_stub = '''
//this file was generated by {script}

#include "operator_{name}.h"

__attribute__((weak))
op_status operator_{name}(
  size_t                  n_input,
  Onnx__TensorProto    ** input,
  size_t                  n_attribute,
  Onnx__AttributeProto ** attribute,
  size_t                  n_output,
  Onnx__TensorProto    ** output
){{
  fprintf(stderr, "Operator {name} not implemented!\\n");
  return OP_STUB;
}}
'''

template_operators = '''
//this file was generated by {script}

#ifndef OPERATORS_H
#define OPERATORS_H

{includes}

#endif
'''

def size_constraint(min, max):
  if (min == max):
    return "always {0}".format(min)
  else:
    return "{0} to {1}".format(min, max)

def format_text(prefix, start, texts):
  output = []

  curr = [start]
  for text in texts:
    lines = []
    length = len(prefix) + len(start)
    # split text into words by splitting on space and remove empty splits ("  ")
    # then split on newline boundaries, but keep emtpy splits ("\n\n") 
    words = [ w.split("\n") for w in text.strip().split(" ") if w!=""]
    words = list(itertools.chain(*words))
    for w in words:
      if w == "":
        # empty split, caused by "\n\n", should cause line break
        length = len(prefix) + len(start) + len(w)
        lines.append(prefix + " ".join(curr))
        curr = [" "*len(start)]
        continue
      if length + len(w) < 79:
        # keep adding words
        length += len(w) + 1
        curr.append(w)
        continue
      
      # line is full, do line break
      length = len(prefix) + len(start) + len(w)
      lines.append(prefix + " ".join(curr))
      curr = [" "*len(start)]
      curr.append(w)
    lines.append(prefix + " ".join(curr))
    curr = [" "*len(start)]
    output.append("\n".join(lines))
  
  return "\n".join(output)


for schema in schemas:
  deprecated = " * "
  deprecated_define = ""
  documentation = " * "
  constraints = []
  attributes = []

  if schema.domain == '':
    documentation += "@see https://github.com/onnx/onnx/blob/master/docs/Operators.md#" + schema.name
  elif schema.domain == 'ai.onnx.ml':
    documentation += "@see https://github.com/onnx/onnx/blob/master/docs/Operators-ml.md#" + schema.name

  if schema.deprecated:
    deprecated += "@deprecated Avoid usage!"
    deprecated_define = "#define OPERATOR_{NAME}_DEPRECATED 1"
  
  brief = format_text(" * @brief","",[schema.doc])

  for c in schema.type_constraints:
    types = list(c.allowed_type_strs)
    types.sort()
    constraints.append(format_text(" * @detail ", f"Type {c.type_param_str}:", [c.description, ", ".join(types)]))

  for i in schema.inputs:
    types = list(c.allowed_type_strs)
    types.sort()
    constraints.append(format_text(" * @detail ", f"Input {i.typeStr} {i.name}:", [i.description, ", ".join(types)]))
 
  for o in schema.outputs:
    types = list(c.allowed_type_strs)
    types.sort()
    constraints.append(format_text(" * @detail ", f"Output {o.typeStr} {o.name}:", [o.description, ", ".join(types)]))

  for a in schema.attributes.values():
    required = "(optional)"
    if a.required:
      required = "(required)"
    attributes.append(format_text(" * @detail ", f"Attribute {a.type.name} {a.name}:", [a.description, required]))

  if attributes:
    attributes = "\n".join(attributes)
  else:
    attributes = " *"

  if constraints:
    constraints = "\n".join(constraints)
  else:
    constraints = " *"

  header = template_header.format(
    _ws_=" "*len(schema.name),
    attributes=attributes,
    brief=brief,
    constraints=constraints,
    deprecated_define=deprecated_define,
    deprecated=deprecated,
    documentation=documentation,
    file=os.path.relpath(schema.file, path_include),
    input_constraint=size_constraint(schema.min_input, schema.max_input),
    line=schema.line,
    Name=schema.name.capitalize(),
    name=schema.name.lower(),
    NAME=schema.name.upper(),
    output_constraint=size_constraint(schema.min_output, schema.max_output),
    script=inspect.getfile(inspect.currentframe()),
    since=schema.since_version,
  )
  stub = template_stub.format(
    _ws_=" "*len(schema.name),
    name=schema.name.lower(),
    script=inspect.getfile(inspect.currentframe()),
  )
  open(f"{path_include}/operator_{schema.name.lower()}.h","w").write(header)
  open(f"{path_stubs}/operator_{schema.name.lower()}.c","w").write(stub)

includes = [ f'#include "operator_{s.name.lower()}.h"' for s in schemas ]
operators = template_operators.format(
  includes="\n".join(includes),
  script=inspect.getfile(inspect.currentframe()),
)

open(f"{path_include}/operators.h","w").write(operators)
