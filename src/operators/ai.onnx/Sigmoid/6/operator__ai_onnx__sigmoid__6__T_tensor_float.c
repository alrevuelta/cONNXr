//this file was generated by ../../../../../../scripts/onnx_generator/OperatorStubs.py
#include "operators/ai.onnx/Sigmoid/6/operator__ai_onnx__sigmoid__6.h"

#include "tracing.h"
#include "utils.h"
#include <math.h>
#include <stdlib.h>


static inline
void
sigmoid(float *in, float *out, int num) {
    // Numerically stable Sigmoid implementation
    for (int i = 0; i < num; i++) 
    {
        if (in[i] >= 0)
        {
            out[i] = 1.0 / ( 1.0 + expf(-1*in[i]));
        }
        else 
        {
            out[i] = expf(in[i]) / (1.0 + expf(in[i]));
        }
    }
}

operator_status
operator__ai_onnx__sigmoid__6__T_tensor_float(
    node_context *ctx
)
{
    TRACE_ENTRY(1);

    Onnx__TensorProto *t_input  = searchInputByName(ctx, 0);
    Onnx__TensorProto *t_output = searchOutputByName(ctx, 0);
    Onnx__AttributeProto *a_axis = searchAttributeNyName(ctx->onnx_node->n_attribute, ctx->onnx_node->attribute, "axis");

    TRACE_TENSOR(2,true,t_input);
    TRACE_ATTRIBUTE(2, a_axis, a_axis);

    //wrap axis if negative
    int axis = a_axis?a_axis->i:1;
    if (axis < 0) {
        axis += t_input->n_dims;
    }

    t_output->has_raw_data = 0;
    t_output->data_type = t_input->data_type;
    t_output->n_dims = t_input->n_dims;
    t_output->dims = malloc(t_output->n_dims * sizeof(int64_t));
    t_output->n_float_data = t_input->n_float_data;
    t_output->float_data = malloc(t_output->n_float_data * sizeof(float));

    int N = 1;
    int D = 1;
    for (int i = 0; i < t_input->n_dims; i++) {
        if (i < axis) {
            N *= t_input->dims[i];
        } else {
            D *= t_input->dims[i];
        }
        t_output->dims[i] = t_input->dims[i];
    }

    for (int n = 0; n < N; n++) {
        int offset = D*n;
        sigmoid(&t_input->float_data[offset], &t_output->float_data[offset], D);
    }

    TRACE_TENSOR(2,true,t_output);
    TRACE_EXIT(1);
    return OP_OK;
}